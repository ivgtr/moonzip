# moonzip タスクリスト

fflate (https://github.com/101arrowz/fflate) との100%互換を目指す MoonBit 圧縮・解凍ライブラリ。

**開発方針**: TDD（テスト駆動開発）— 各フェーズでまず全テストを記述し、その後テストが通るように実装する。

> **注意**: fflate の非同期API（Web Worker / worker_threads ベース）は JS ランタイム固有の機能のため、moonzip では対象外とする。同期API・ストリーミングAPIの完全互換を目標とする。

---

## ワークフロー規約

### タスク進行ルール

1. **タスク単位でコミットする**
   - 各タスク（`0-0a`, `1-T1`, `1-1` 等）の完了時に1コミットを作成する
   - コミットメッセージ形式: `<phase>: <タスクID> <簡潔な説明>`
   - 例: `phase0: 0-0a clean up template files`
   - 例: `phase1: 1-T1 add CRC32 tests`
   - 例: `phase1: 1-1 implement CRC32`

2. **テスト→実装→検証の反復サイクル**
   - **テストタスク（`*-T*`）完了時**: テストコードを記述し `moon check` が通ることを確認してコミット（テストは実装前なので FAIL で良い。ただしコンパイルは通す — スタブ/未実装マーカーを使用）
   - **実装タスク（`*-N`）完了時**: `moon test` を実行し、該当テストが全て PASS することを確認してコミット
   - テストが FAIL した場合: テストコードではなく実装を修正する（テスト要件が正しい前提）。テスト自体にバグがある場合のみテストを修正し、修正理由をコミットメッセージに明記する

3. **フェーズ完了時のゲート**
   - 各フェーズの全タスク完了後に `moon test` で全テスト PASS を確認
   - `moon fmt` でコード整形
   - `moon info` でインターフェース更新、`.mbti` の差分を確認
   - ゲート通過後に次のフェーズに進む

### コミット粒度の目安

| タスク種別 | コミットタイミング | 前提条件 |
|-----------|------------------|---------|
| 整理タスク (`0-0*`) | 各サブタスク完了時 | `moon check` PASS |
| テストタスク (`*-T*`) | テストコード記述完了時 | `moon check` PASS（コンパイル通過） |
| 実装タスク (`*-N`) | 対応テスト全 PASS 時 | `moon test` PASS |
| 統合テスト (`9-*`) | テスト追加＋全 PASS 時 | `moon test` PASS |

### テスト実行コマンド

```sh
moon check              # コンパイルチェック（テスト記述後に使用）
moon test               # 全テスト実行（実装後に使用）
moon test --update      # スナップショット更新（必要時のみ）
moon fmt                # コード整形
moon info               # インターフェース更新
moon coverage analyze   # カバレッジ確認
```

---

## 実装可能性チェック

### MoonBit 固有の考慮事項

| 課題 | 対策 | 影響タスク |
|------|------|----------|
| `Uint8Array` がない | MoonBit の `Bytes` または `FixedArray[Byte]` を使用。公開APIでどちらを採用するか Phase 0 で決定 | 全フェーズ |
| JS のコールバック型がない | ストリーミングAPIは MoonBit の trait / メソッド呼び出しパターンで設計 | Phase 7 |
| `Date` 型の互換性 | ZIP の MS-DOS 日時は整数演算のみで実現可能。MoonBit の標準ライブラリの日時型を確認 | Phase 6 (6-5) |
| 大規模テストデータの埋め込み | ハードコードされたバイト配列、またはテスト内でデータ生成関数を作成 | Phase 0 (0-3), Phase 9 |
| クロスライブラリテスト | fflate で事前生成したバイナリフィクスチャをテストデータとして埋め込み。JS テストハーネスは別途作成（`testdata/generate.mjs`） | Phase 9 (9-1, 9-2) |
| ビット演算の符号 | MoonBit の `Int` は符号付き。CRC32 等で `UInt` またはビットマスクが必要 | Phase 1 (1-1) |
| 動的バッファ拡張 | MoonBit の `Buffer` または手動で `FixedArray` を再確保するユーティリティを作成 | Phase 2 (2-1, 2-3) |

### 依存関係グラフ

```
Phase 0 ─── Phase 1 ─── Phase 2 ─── Phase 3
                                 │        │
                                 │        ├── Phase 4
                                 │        │       │
                                 │        │       ├── Phase 5
                                 │        │       │
                                 │        └───────┘
                                 │
                                 ├── Phase 6 (Phase 1 + Phase 2 に依存)
                                 │
                                 ├── Phase 7 (Phase 2-6 全てに依存)
                                 │
                                 └── Phase 8 (独立、ただし Phase 6 ZIP で使用)

Phase 9 ─── 全フェーズに依存
```

### リスクと対策

| リスク | 影響度 | 対策 |
|--------|--------|------|
| MoonBit のビット演算パフォーマンスが不十分 | 中 | Phase 1 完了後にベンチマークを取り、問題があれば WASM intrinsics を検討 |
| fflate の圧縮出力とバイト単位で一致しない | 低 | 完全一致は不要。ラウンドトリップ一致（圧縮→解凍で元データに戻る）と圧縮率5%以内を基準とする |
| ストリーミング API の設計が MoonBit に合わない | 中 | Phase 7 の前に API 設計のプロトタイプを作成し検証。必要なら fflate と異なるインターフェースを採用（動作互換は維持） |
| 大規模テストデータでメモリ不足 | 低 | WASM のメモリ上限に注意。テストデータは段階的に大きくし、Phase 9 の大規模テストは最後に実施 |
| ZIP64 のテストデータ生成が困難 | 中 | 4GB超ファイルは不要。ZIP64 ヘッダのパース部分のみをバイナリフィクスチャでテスト |

---

## Phase 0: プロジェクト基盤

### 既存ファイルの整理
- [ ] **0-0a** テンプレートファイルの整理
  - `moonzip.mbt`: テンプレートコメントを削除し、公開API定義の起点にする
  - `moonzip_test.mbt`: テンプレートコメントを削除（Phase 1以降でテスト記述）
  - `moonzip_wbtest.mbt`: テンプレートコメントを削除（Phase 1以降でテスト記述）
- [ ] **0-0b** `cmd/` ディレクトリの整理
  - `cmd/main/main.mbt`: Hello World を削除、ライブラリプロジェクトのため `cmd/` 自体が不要であれば削除を検討
  - `cmd/main/moon.pkg`: コメント化された import を整理
- [ ] **0-0c** プロジェクトメタデータの更新
  - `moon.mod.json`: `description` を記入（例: "A MoonBit compression library compatible with fflate"）
  - `moon.mod.json`: `keywords` を記入（例: `["compression", "deflate", "gzip", "zlib", "zip"]`）
  - `moon.mod.json`: `repository` を記入
  - `README.mbt.md`: プレースホルダ `# username/moonzip` を実際のプロジェクト説明に置き換え
- [ ] **0-0d** AGENTS.md の更新
  - 現在は汎用テンプレート。moonzip 固有の情報（アーキテクチャ概要、パッケージ構成、テスト方針）を追記
- [ ] **0-0e** .gitignore の確認・更新
  - 現在: `.DS_Store`, `_build/`, `.mooncakes/`, `.moonagent/`
  - 必要に応じて `testdata/` 内の大規模バイナリの除外ルール等を追加

### パッケージ構成・型定義
- [ ] **0-1** パッケージ構成の設計と作成
  - ルートパッケージ (`moonzip`): 公開API
  - 内部パッケージ候補: `internal/bits`, `internal/checksum`, `internal/huffman`, `internal/lz77`, `internal/deflate`, `internal/gzip`, `internal/zlib`, `internal/zip`
  - 各パッケージに `moon.pkg` の依存関係定義
  - ルートの `moon.pkg` に内部パッケージの import を定義
- [ ] **0-2** 共通型・エラー型の定義
  - `FlateError` 型（fflate の 15 種類のエラーコードに対応）
  - `DeflateOptions`, `InflateOptions` などのオプション型
  - ストリーミング用コールバック型

### テスト基盤
- [ ] **0-3** テストデータセットの準備
  - 標準テストベクタ（既知の入出力ペア）を `testdata/` に配置
  - fflate で生成した各フォーマットのバイナリデータ（DEFLATE, GZIP, Zlib, ZIP）
  - 標準ツール（gzip, zlib）で生成した参照データ
  - 各ブロックタイプを意図的に発生させるデータパターン

---

## Phase 1: コアユーティリティ（テスト → 実装）

### テスト作成
- [ ] **1-T1** CRC32 テスト
  - 既知のテストベクタ: `""` → `0x00000000`, `"123456789"` → `0xCBF43926` (RFC 3720)
  - 空入力（0バイト）
  - 1バイト入力（全256値のうち代表的な値）
  - ASCII文字列: `"Hello world!"`
  - 大規模データ（64KB超）
  - 全て0x00のデータ、全て0xFFのデータ
  - インクリメンタル計算: データを分割して逐次計算した結果が一括計算と一致
  - インクリメンタル計算: 1バイトずつ、2バイトずつ、ランダムサイズで分割
  - fflate の CRC32 出力との一致検証（バイナリレベル）
- [ ] **1-T2** Adler-32 テスト
  - 既知のテストベクタ: `""` → `0x00000001`, `"Wikipedia"` → `0x11E60398` (RFC 1950)
  - 空入力（0バイト）→ 初期値 `1` が返ること
  - 1バイト入力
  - 2,654バイトデータ（モジュラリダクション境界直前）
  - 2,655バイトデータ（モジュラリダクション発生）
  - 2,656バイトデータ（モジュラリダクション直後）
  - 大規模データ（65521バイト超 — mod 65521 が複数回発生）
  - 全て0x00のデータ、全て0xFFのデータ（オーバーフロー耐性）
  - インクリメンタル計算: 分割計算と一括計算の一致
  - fflate の Adler-32 出力との一致検証
- [ ] **1-T3** ビット操作テスト
  - `bits()`: 1ビットから15ビットまでの読み取り
  - `bits()`: バイト境界をまたぐ読み取り（例: 3ビット目から11ビット読み取り）
  - `bits16()`: 16ビット以上の読み取り
  - `wbits()`: 1ビットから15ビットまでの書き込み
  - `wbits()`: バイト境界をまたぐ書き込み
  - `wbits16()`: 16ビット以上の書き込み
  - `shft()`: 各ビット位置（0-7）からのバイト境界アライメント
  - `b2()`: 0x0000, 0xFFFF, 0x0100（エンディアン検証）
  - `b4()`: 0x00000000, 0xFFFFFFFF, 0x01020304
  - `b8()`: 8バイト値の読み取り（ZIP64用）
  - `wbytes()`: 2, 4バイトのリトルエンディアン書き込み
  - 読み書きラウンドトリップ: 書き込んだビット列を読み戻して一致検証
  - バッファ末尾ぎりぎりでの読み書き
- [ ] **1-T4** ハフマン符号テスト
  - **固定テーブル検証**:
    - リテラル 0-143 → 8ビット
    - リテラル 144-255 → 9ビット
    - リテラル 256-279 → 7ビット
    - リテラル 280-287 → 8ビット
    - 距離コード 0-29 → 全て5ビット
  - **ツリー構築 (`hTree`)**:
    - 空の頻度テーブル → 空の結果
    - 単一シンボルの頻度テーブル → 長さ1のコード
    - 2シンボル（等頻度）→ 各1ビット
    - 偏った分布（1つのシンボルが支配的）
    - 全シンボル等頻度（最大深度に近い）
    - ビット長が15を超える場合のdebtリバランシング
  - **コードマップ (`hMap`)**:
    - 正方向マップ: シンボル→コード の正確性
    - 逆方向マップ: コード→シンボル の正確性
    - ラウンドトリップ: 符号化→復号で元シンボルに戻ること
  - **コード長RLE (`lc`)**:
    - 長さ0の連続: 3-10個→シンボル17、11-138個→シンボル18
    - 前値と同じ長さの連続: 3-6個→シンボル16
    - 混在パターン
  - **16ビットビット反転テーブル**: 全65536値のラウンドトリップ

### 実装
- [ ] **1-1** CRC32 実装
- [ ] **1-2** Adler-32 実装
- [ ] **1-3** ビット操作ユーティリティ実装
- [ ] **1-4** ハフマン符号実装

---

## Phase 2: DEFLATE（テスト → 実装）

### テスト作成
- [ ] **2-T1** inflate（解凍）基本テスト
  - **ブロックタイプ別**:
    - Type 0（無圧縮）: 手動構築したバイナリ + fflate level=0 出力
    - Type 1（固定ハフマン）: 短い文字列のデフォルト圧縮結果
    - Type 2（動的ハフマン）: 長い文字列の圧縮結果
    - 3種ブロック混在データ（fflate が自動選択するケース）
  - **データパターン別**:
    - 空データ（0バイト）
    - 1バイト
    - "Hello world!" (12バイト)
    - 全て同一バイト (1KB) — 高圧縮率
    - 繰り返しパターン (例: "abcabc..." 10KB)
    - 大規模テキスト (100KB+)
    - 大規模バイナリ (BMP相当、500KB+)
    - 完全ランダム (1KB) — ほぼ非圧縮
    - 64KB境界データ (65534, 65535, 65536, 65537バイト) — ブロック分割境界
  - **クロスライブラリ**: fflate/pako/zlib で圧縮したデータを moonzip で解凍
  - **出力サイズヒント**: `size` オプションで正確なサイズを指定した場合の動作
- [ ] **2-T2** inflate エラーテスト
  - 切り詰めデータ（unexpected EOF — エラーコード0）
  - 不正ブロックタイプ（type=3 — エラーコード1）
  - 不正な長さリテラル（ハフマンコードが0 — エラーコード2）
  - 不正な距離コード（ハフマンコードが0 — エラーコード3）
  - Type 0 ブロックの長さフィールドが残データを超過
  - Type 0 ブロックの長さと反転長さの不一致
  - 距離がウィンドウサイズ(32768)を超過
  - 距離がこれまでの出力サイズを超過（辞書なしの場合）
- [ ] **2-T3** deflate（圧縮）ラウンドトリップテスト
  - **全レベル (0-9)** × 各データパターン:
    - 空データ
    - 1バイト
    - "Hello world!"
    - 全て同一バイト (1KB)
    - 繰り返しパターン (10KB)
    - テキストデータ (100KB+)
    - バイナリデータ (500KB+)
    - ランダムデータ (1KB)
  - 各レベルで `deflateSync` → `inflateSync` のラウンドトリップ一致
  - レベル0: 無圧縮ブロック(Type 0)であること、サイズが入力+ヘッダオーバーヘッド
  - レベル1: レベル9より高速だが圧縮率は低い（サイズ比較）
  - レベル9: 最高圧縮率（サイズ比較）
  - moonzip deflate → fflate inflateSync で解凍可能であること（互換性）
- [ ] **2-T4** deflate オプションテスト
  - `level`: 0-9 全レベルの動作検証
  - `level` 未指定: デフォルト6が使用されること
  - `mem`: 0, 4（デフォルト）, 8, 12 の各値
  - `mem` 未指定: 入力サイズに基づく自動決定
  - `dictionary`: カスタム辞書ありの圧縮・解凍ラウンドトリップ
  - `dictionary`: 32KB超の辞書が32KBに切り詰められること
  - `dictionary`: 辞書ありで圧縮、辞書なしで解凍 → エラー
  - `dictionary`: 異なる辞書で解凍 → データ不一致
- [ ] **2-T5** deflate ブロック分割テスト
  - 24,576シンボル超のデータ → 複数ブロックに分割
  - 7,000文字マッチ超のデータ → 強制分割
  - 各ブロックが最小ビット数のタイプで出力されること
  - 65,535バイト超の無圧縮データ → 複数のType 0ブロック
- [ ] **2-T6** LZ77 テスト（ホワイトボックス）
  - 最小マッチ長（3バイト）の検出
  - 3バイト未満はマッチしないこと
  - 最大マッチ長（258バイト）の正確な境界
  - 259バイトの繰り返しが258+1に分割されること
  - 最大距離（32,768バイト）のマッチ検出
  - 32,769バイト離れたマッチは検出されないこと
  - ハッシュ衝突時のチェーン走査
  - nice閾値によるマッチ探索の早期終了
- [ ] **2-T7** 圧縮率テスト
  - fflate との圧縮率比較（各レベルで5%以内）
  - テストデータ: テキスト、バイナリ、混合
  - レベル9での最大圧縮率

### 実装
- [ ] **2-1** DEFLATE 解凍エンジン (`inflt`)
- [ ] **2-2** LZ77 圧縮エンジン
- [ ] **2-3** DEFLATE 圧縮エンジン (`dflt`)
- [ ] **2-4** `deflateSync` / `inflateSync` 公開API

---

## Phase 3: GZIP（テスト → 実装）

### テスト作成
- [ ] **3-T1** gzipSync ラウンドトリップテスト
  - 空データ、1バイト、典型文字列、大規模データ
  - 全レベル (0-9) でのラウンドトリップ
  - moonzip gzip → fflate gunzip 互換性
  - moonzip gzip → システム `gzip -d` 互換性
- [ ] **3-T2** gzipSync ヘッダ正確性テスト
  - マジックナンバー: バイト[0]=0x1f, [1]=0x8b
  - CM: バイト[2]=8
  - FLG: オプション未指定時は0
  - MTIME: デフォルト値、`mtime` オプション指定時の値
  - MTIME: `mtime=0` で特殊ケース（未知の時刻）
  - XFL: level<=2で4, level>=7で2, それ以外で0
  - OS: 255（不明）
- [ ] **3-T3** gzipSync オプションテスト
  - `filename`: 設定時にFNAMEフラグ(bit 3)が立ち、NULL終端文字列が含まれること
  - `comment`: 設定時にFCOMMENTフラグ(bit 4)が立つこと
  - `extra`: 設定時にFEXTRAフラグ(bit 2)が立つこと
  - `mtime`: Date型、数値型、文字列型の各指定
  - `level`: XFLフィールドへの反映
  - 複数オプション同時指定（FEXTRA + FNAME + FCOMMENT）
- [ ] **3-T4** gunzipSync 基本テスト
  - fflate `gzipSync` 出力の解凍
  - システム `gzip` で生成したデータの解凍
  - 各オプション付きGZIPデータの解凍（FEXTRA, FNAME, FCOMMENT, FHCRC）
  - CRC32 フッタの検証が正しく行われること
  - ISIZE フッタの検証が正しく行われること
- [ ] **3-T5** gunzipSync エラーテスト
  - 不正マジックナンバー（[0]!=0x1f or [1]!=0x8b）→ エラーコード6
  - 不正CM（[2]!=8）→ エラーコード6
  - データが18バイト未満（最小GZIPサイズ）→ エラーコード0
  - CRC32 不一致 → エラー
  - ISIZE 不一致 → エラー
  - 切り詰めデータ（ヘッダ途中、圧縮データ途中、フッタ途中）
- [ ] **3-T6** マルチメンバーGZIP テスト
  - 2つのGZIPメンバーを連結したデータの解凍
  - 3つ以上のメンバー連結
  - 各メンバーのデータが独立して正しいこと
  - 空データメンバーを含む連結

### 実装
- [ ] **3-1** GZIP ヘッダ書き込み (`gzh`)
- [ ] **3-2** GZIP ヘッダ/フッタ解析 (`gzs`, `gzl`)
- [ ] **3-3** `gzipSync` / `gunzipSync` 公開API

---

## Phase 4: Zlib（テスト → 実装）

### テスト作成
- [ ] **4-T1** zlibSync ラウンドトリップテスト
  - 空データ、1バイト、典型文字列、大規模データ
  - 全レベル (0-9) でのラウンドトリップ
  - moonzip zlib → fflate unzlib 互換性
- [ ] **4-T2** zlibSync ヘッダ正確性テスト
  - CMF: 下位4ビット=8 (Deflate), 上位4ビット=7 (32KBウィンドウ)
  - FLG: FCHECK が `(CMF*256+FLG) % 31 == 0` を満たすこと
  - FLEVEL: level 0-1→0, 2-5→1, 6→2, 7-9→3
  - 辞書なし: FDICT=0, DICTIDなし
- [ ] **4-T3** zlibSync 辞書テスト
  - 辞書あり: FDICT=1, DICTID (Adler-32) が正しいこと
  - 辞書ありでのラウンドトリップ
  - 辞書ありで圧縮、辞書なしで解凍 → エラーコード6
  - 辞書なしで圧縮、辞書ありで解凍 → エラーコード6
- [ ] **4-T4** unzlibSync テスト
  - fflate `zlibSync` 出力の解凍
  - 各FLEVELのデータ
  - Adler-32 フッタ検証が正しく行われること
- [ ] **4-T5** unzlibSync エラーテスト
  - 不正CM（下位4ビット!=8）→ エラーコード6
  - 不正CINFO（上位4ビット>7）→ エラーコード6
  - FCHECKサム不正（`(CMF<<8|FLG)%31 != 0`）→ エラーコード6
  - Adler-32 不一致 → エラー
  - 切り詰めデータ → エラーコード0
  - 辞書フラグ不一致 → エラーコード6

### 実装
- [ ] **4-1** Zlib ヘッダ作成 (`zlh`)
- [ ] **4-2** Zlib ヘッダ検証 (`zls`)
- [ ] **4-3** `zlibSync` / `unzlibSync` 公開API

---

## Phase 5: 自動検出解凍（テスト → 実装）

### テスト作成
- [ ] **5-T1** decompressSync 正常系テスト
  - GZIP データ (`0x1f 0x8b`) → 正しく解凍
  - Zlib データ (`0x78 ...`) → 正しく解凍
  - raw DEFLATE データ → 正しく解凍
  - 各フォーマットで同じ入力データを圧縮→decompressSyncで解凍→一致
- [ ] **5-T2** decompressSync エッジケーステスト
  - 先頭が `0x1f` だがGZIPではないデータ → raw DEFLATEとして処理
  - 先頭が `0x78` だがZlibヘッダチェックサムが不正 → raw DEFLATEとして処理
  - 空データ
  - 不正データ → 適切なエラー

### 実装
- [ ] **5-1** `decompressSync` 実装

---

## Phase 6: ZIP（テスト → 実装）

### テスト作成
- [ ] **6-T1** zipSync 基本テスト
  - 単一ファイル（1ファイル、Deflate圧縮）
  - 複数ファイル（3-5ファイル）
  - 空のファイル（0バイトコンテンツ）
  - ディレクトリエントリ（末尾スラッシュのファイル名）
  - ネストされた `Zippable` 構造 → フラットなパスに展開
  - ラウンドトリップ: zipSync → unzipSync → 全ファイル一致
  - moonzip zipSync → システム `unzip` で解凍可能
  - moonzip zipSync → fflate `unzipSync` で解凍可能
- [ ] **6-T2** zipSync オプションテスト
  - `level`: 0 (Store) — 圧縮方式=0, サイズ一致
  - `level`: 1-9 (Deflate) — 圧縮方式=8
  - ファイル別オプション: `[data, { level: 0 }]` タプル形式
  - ファイル別に異なる圧縮レベル
  - `mtime`: Date型、数値型、文字列型
  - `mtime` 未指定: 現在時刻が使用されること
  - `os`: OS識別子の設定
  - `attrs`: ファイル属性の設定
  - `comment`: ファイルコメント
  - `extra`: 拡張フィールド（Record<number, Uint8Array>）
- [ ] **6-T3** zipSync 構造正確性テスト
  - Local File Header: シグネチャ `0x04034B50`, バージョン20, 各フィールドのオフセットと値
  - Central Directory: シグネチャ `0x02014B50`, Local File Headerとの整合性
  - End of Central Directory: シグネチャ `0x06054B50`, ファイル数、CDサイズ、CDオフセット
  - CRC32: 各ファイルのCRC32が正しいこと
  - ファイルサイズ: 圧縮前・圧縮後サイズの正確性
  - UTF-8フラグ: 非ASCIIファイル名でbit 11が立つこと
  - ASCII ファイル名: bit 11が立たないこと
- [ ] **6-T4** zipSync MS-DOS日時テスト
  - 1980-01-01 00:00:00 (最小値)
  - 2099-12-31 23:59:58 (最大値付近)
  - 2024-06-15 12:30:45 (一般的な値)
  - 秒の偶数丸め（奇数秒→偶数に丸められること）
  - 1980年未満 → エラーコード10
  - 2099年超 → エラーコード10
- [ ] **6-T5** unzipSync 基本テスト
  - fflate `zipSync` 出力の解凍
  - システム `zip` で作成したZIPの解凍
  - Store (method=0) ファイルの解凍
  - Deflate (method=8) ファイルの解凍
  - 混在（Store + Deflate）ZIPの解凍
  - 複数ファイル・ディレクトリ構造の復元
  - UTF-8ファイル名（日本語等）の正確なデコード
  - Latin-1ファイル名（bit 11なし）のデコード
- [ ] **6-T6** unzipSync オプション・フィルタテスト
  - `filter`: 特定ファイルのみ解凍
  - `filter`: 全ファイル除外 → 空の結果
  - `filter`: ファイル情報（name, size, originalSize, compression）の正確性
- [ ] **6-T7** unzipSync エラーテスト
  - EOCD シグネチャが見つからない → エラーコード13
  - 不正なLocal File Headerシグネチャ
  - 未知の圧縮方式（method=1等）→ エラーコード14
  - CRC32 不一致
  - 切り詰めデータ
  - 空のバイト列
- [ ] **6-T8** ZIP64 読み取りテスト
  - ZIP64 EOCD Locator の検出
  - ZIP64拡張情報フィールドからのサイズ/オフセット読み取り
  - ファイル数が65535のZIP32との境界
- [ ] **6-T9** ZIP 拡張フィールド・制限テスト
  - `extra` フィールドの書き込みと読み取りラウンドトリップ
  - ファイル名65535バイト（制限値）→ 成功
  - ファイル名65536バイト超 → エラーコード11
  - extra フィールド65535バイト（制限値）→ 成功
  - extra フィールド65536バイト超 → エラーコード9

### 実装
- [ ] **6-1** ZIP ヘッダ書き込み (`wzh`)
- [ ] **6-2** ZIP フッタ書き込み (`wzf`)
- [ ] **6-3** ZIP ヘッダ解析 (`zh`, `slzh`, `z64e`)
- [ ] **6-4** `Zippable` 展開 (`fltn`)
- [ ] **6-5** MS-DOS 日時変換
- [ ] **6-6** `zipSync` 公開API
- [ ] **6-7** `unzipSync` 公開API

---

## Phase 7: ストリーミングAPI（テスト → 実装）

### テスト作成
- [ ] **7-T1** Deflate ストリーミング基本テスト
  - チャンク入力 → 全出力結合 → inflateSync で解凍 → 元データ一致
  - チャンクサイズ: 1バイト、100バイト、1KB、64KB、128KB
  - ランダムサイズチャンク（fflate のテストユーティリティと同等）
  - 全レベル (0-9) でのストリーミング圧縮
  - 空チャンク (0バイト) の入力が正しく処理されること
  - 最初のチャンクが空、中間チャンクが空、最後のチャンクが空
  - `flush()` 呼び出し後に中間データが出力されること
  - `flush()` 後に追加データを入力して最終出力が正しいこと
- [ ] **7-T2** Inflate ストリーミング基本テスト
  - deflateSync の出力をチャンク分割 → Inflate → 全出力結合 → 元データ一致
  - 1バイトずつの入力（最小チャンク）
  - ブロック境界をまたぐチャンク分割
  - ハフマンコード途中でのチャンク分割
  - 出力サイズヒント (`size`) あり/なし
- [ ] **7-T3** ストリーミングエラーテスト
  - 完了後 (`final=true` 送信後) に再度 `push` → エラーコード4
  - `ondata` 未設定で `push` → エラーコード5
  - 不正データの入力 → 適切なエラーコード
- [ ] **7-T4** Gzip / Gunzip ストリーミングテスト
  - Gzip: チャンク入力 → gunzipSync で解凍 → 一致
  - Gunzip: gzipSync の出力をチャンク分割 → 解凍 → 一致
  - Gunzip: オプション付きGZIP（FNAME等）のストリーミング解凍
  - `flush()` の動作
- [ ] **7-T5** Gunzip マルチメンバーストリーミングテスト
  - 2つのGZIPメンバー連結データのストリーミング解凍
  - `onmember` コールバックが正しいオフセットで呼ばれること
  - メンバー境界がチャンク境界と一致する場合
  - メンバー境界がチャンク途中の場合
- [ ] **7-T6** Zlib / Unzlib ストリーミングテスト
  - Zlib: チャンク入力 → unzlibSync で解凍 → 一致
  - Unzlib: zlibSync の出力をチャンク分割 → 解凍 → 一致
  - Unzlib: ヘッダが6バイト未満のチャンクで分割される場合の遅延解析
- [ ] **7-T7** Decompress ストリーミングテスト
  - GZIP データのストリーミング → 正しく検出・解凍
  - Zlib データのストリーミング → 正しく検出・解凍
  - raw DEFLATE データのストリーミング → 正しく検出・解凍
  - 先頭3バイト未満のチャンクでの判定遅延
- [ ] **7-T8** Zip ストリーミング作成テスト
  - `ZipPassThrough`: Store方式でファイル追加、Data Descriptor生成
  - `ZipDeflate`: Deflate方式でファイル追加
  - `Zip`: 複数ファイルの逐次追加 → unzipSync で解凍 → 一致
  - `Zip.add()` → `Zip.end()` の順序
  - ファイル追加中の `ondata` コールバック呼び出し
- [ ] **7-T9** Unzip ストリーミング解凍テスト
  - zipSync 出力をチャンク分割 → Unzip → 全ファイル復元
  - `onfile` コールバックでファイル情報が正しいこと
  - `UnzipPassThrough` (Store) の登録と動作
  - `UnzipInflate` (Deflate) の登録と動作
  - `Unzip.register()` によるカスタムデコーダ登録
  - Data Descriptor 付きZIPの解凍
  - 終了処理中 (`finishing`) に追加操作 → エラーコード12
  - 最終チャンク時にデータ残存 → エラーコード13

### 実装
- [ ] **7-1** ストリーミング基盤（状態管理、32KBウィンドウ）
- [ ] **7-2** `Deflate` / `Inflate` ストリーミングクラス
- [ ] **7-3** `Gzip` / `Gunzip` ストリーミングクラス
- [ ] **7-4** `Zlib` / `Unzlib` ストリーミングクラス
- [ ] **7-5** `Decompress` ストリーミングクラス
- [ ] **7-6** ZIP ストリーミングクラス群

---

## Phase 8: UTF-8 ユーティリティ（テスト → 実装）

### テスト作成
- [ ] **8-T1** strToU8 テスト
  - ASCII文字列: `"Hello"` → `[72, 101, 108, 108, 111]`
  - 空文字列 → 空配列
  - 2バイト文字: `"é"` (U+00E9) → `[0xC3, 0xA9]`
  - 3バイト文字: `"日"` (U+65E5) → `[0xE6, 0x97, 0xA5]`
  - 4バイト文字: `"𝄞"` (U+1D11E, 音楽記号) → `[0xF0, 0x9D, 0x84, 0x9E]`
  - 絵文字: `"😀"` (U+1F600) → 4バイトUTF-8
  - 混合文字列: `"Hello 世界! 🌍"`
  - サロゲートペア（JSのUTF-16表現 → 正しいUTF-8変換）
  - `latin1=true`: 各バイトをそのまま文字コードとして扱う
- [ ] **8-T2** strFromU8 テスト
  - 有効なUTF-8バイト列 → 正しい文字列
  - 空バイト列 → 空文字列
  - 各バイト長（1-4バイト）のシーケンス
  - `latin1=true`: バイト値をそのまま文字として扱う
  - ラウンドトリップ: `strFromU8(strToU8(str))` === str
- [ ] **8-T3** EncodeUTF8 / DecodeUTF8 ストリーミングテスト
  - 文字列チャンク → バイト列チャンク → 結合 → strToU8 と一致
  - マルチバイト文字がチャンク境界で分割される場合
  - DecodeUTF8: 最終チャンクで未完成マルチバイトシーケンス → エラーコード8
  - DecodeUTF8: 不正な継続バイト → エラーコード8
  - 1文字ずつのストリーミング

### 実装
- [ ] **8-1** `strToU8` / `strFromU8` 実装
- [ ] **8-2** `EncodeUTF8` / `DecodeUTF8` ストリーミングクラス

---

## Phase 9: 互換性検証・統合テスト

- [ ] **9-1** クロスライブラリ互換テスト
  - moonzip deflateSync → fflate inflateSync → 一致（全データパターン）
  - fflate deflateSync → moonzip inflateSync → 一致（全データパターン）
  - moonzip gzipSync → fflate gunzipSync → 一致
  - fflate gzipSync → moonzip gunzipSync → 一致
  - moonzip zlibSync → fflate unzlibSync → 一致
  - fflate zlibSync → moonzip unzlibSync → 一致
  - moonzip zipSync → fflate unzipSync → 一致
  - fflate zipSync → moonzip unzipSync → 一致
- [ ] **9-2** システムツール互換テスト
  - moonzip gzipSync → `gzip -d` → 一致
  - `gzip` → moonzip gunzipSync → 一致
  - moonzip zipSync → `unzip` → 一致
  - `zip` → moonzip unzipSync → 一致
- [ ] **9-3** 圧縮率ベンチマーク
  - fflate との圧縮率比較（全レベル、全データパターン、5%以内が目標）
- [ ] **9-4** 大規模データテスト
  - 1MB テキスト
  - 5MB バイナリ
  - 10MB 混合データ
  - 各フォーマット・各レベルでのラウンドトリップ
- [ ] **9-5** エッジケース網羅テスト
  - 空データ（全API）
  - 1バイトデータ（全API）
  - 全て0x00 (1KB, 64KB)
  - 全て0xFF (1KB, 64KB)
  - ランダムデータ (1KB — 非圧縮性)
  - 64KB境界 (65534, 65535, 65536, 65537バイト)
  - 32KB境界 (32767, 32768, 32769バイト — ウィンドウサイズ)

---

## 対象外（MoonBit で非対応）

以下は JavaScript ランタイム固有の機能のため、moonzip では実装しない:

- **非同期API**: `deflate`, `inflate`, `gzip`, `gunzip`, `zlib`, `unzlib`, `decompress`, `zip`, `unzip`（コールバックベース）
- **非同期ストリーミング**: `AsyncDeflate`, `AsyncInflate`, `AsyncGzip`, `AsyncGunzip`, `AsyncZlib`, `AsyncUnzlib`, `AsyncDecompress`, `AsyncZipDeflate`, `AsyncUnzipInflate`
- **Web Worker / worker_threads**: バックグラウンドスレッド処理
- **`ondrain` / `queuedSize`**: 非同期バッファリング制御
- **`terminate()`**: Worker 終了

---

## 実装優先順位

```
Phase 0 (基盤) → Phase 1 (ユーティリティ) → Phase 2 (DEFLATE) → Phase 3 (GZIP)
    → Phase 4 (Zlib) → Phase 5 (自動検出) → Phase 6 (ZIP) → Phase 7 (ストリーミング)
    → Phase 8 (UTF-8) → Phase 9 (統合テスト)
```

各フェーズ内では必ず **テスト作成 → 実装 → テスト PASS 確認 → コミット** の順序で進める。

---

## タスク・テスト・コミット サマリー

| フェーズ | テストタスク | 実装タスク | 想定テスト関数 | 想定コミット数 |
|---------|-----------|----------|-------------|-------------|
| Phase 0 | 0 | 8 | 0 | 8 |
| Phase 1 | 4 | 4 | ~50 | 8 |
| Phase 2 | 7 | 4 | ~80 | 11 |
| Phase 3 | 6 | 3 | ~40 | 9 |
| Phase 4 | 5 | 3 | ~30 | 8 |
| Phase 5 | 2 | 1 | ~10 | 3 |
| Phase 6 | 9 | 7 | ~60 | 16 |
| Phase 7 | 9 | 6 | ~60 | 15 |
| Phase 8 | 3 | 2 | ~20 | 5 |
| Phase 9 | 5 | 0 | ~30 | 5 |
| **合計** | **50** | **38** | **~380** | **~88** |
